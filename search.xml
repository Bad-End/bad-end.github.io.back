<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分图学习笔记]]></title>
    <url>%2Farticle%2Fbipartite-graph%2F</url>
    <content type="text"><![CDATA[二分图又称二部图，是图论中一种特殊模型。对于一个无向图，如果可以把他的顶点分为两个互不相交的子集，并且图中的每一条边，所关联的两个顶点都分别属于两个不同的顶点集，则称该图为二分图。显然二分图中不存在奇数环，如果出现的话无法被划分到任何集合里。 判断通过$ dfs $或者$ bfs $ 对一张图染色（即染色法，共有两种颜色），对于每一条边，使其两个节点的颜色不同。当一个点的颜色已经被确定时，该结点的颜色与当前应该染的颜色冲突，则说明这张图不是二分图。 代码1234567891011void dfs(int u, int color) &#123;//u为当前遍历到的结点，color为该点应该染的颜色，用1， 2来表示 if (col[u]) &#123; if (col[u] != color) return;//说明这张图不是二分图 &#125; else &#123; col[u] = color; &#125; for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; dfs(v, 3 - color);//边的两个端点颜色不同 &#125;&#125; 定义匹配在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。（如图三红边） 相应的，属于「匹配」的边为匹配边，不属于匹配的边为为匹配的边。与匹配边相连的点为匹配点，反之则为未匹配点。 最大匹配一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。例如图四所示的红边，注意一张图的最大匹配方案不一定唯一。 （见图四） 完美匹配对于一张图的某个匹配来说，如果该图的所有点都是匹配点，那么称该匹配为该图的「完美匹配」（图四）。显然，完美匹配一定是最大匹配。 匈牙利算法一种求最大匹配的算法。 交叉路从一个未匹配点出发，依次经过未匹配边、匹配边、未匹配边、匹配边……最终到达另一个点的路径。特别的，一条未匹配边与两个未匹配点组成的路径也是交叉路 增广路最后一个端点为未匹配点的交叉路。特别的，一条未匹配边与两个未匹配点组成的路径也是增广路。增广路的首位两条边都是未匹配边，首尾两个点都是未匹配点，并且边数一定是奇数。既然是奇数，那么增广路中的未匹配边一定比匹配边多一条。 思想根据增广路中未匹配边比匹配边多一条的性质，那么只要把增广路中的边的身份翻转，得到的新的匹配中的边数就会多一。因此匈牙利算法实质上是在不断地找增广路来改进当前的匹配。由此得出，最大匹配中一定不存在增广路，如果有增广路的话，该匹配就可以改进，就不是最大匹配了。 算法流程从二分图的一边开始，以每个点为起点进行$ dfs $或者$ bfs $，每当搜索到一条增广路时，结束搜索。那么显然以一个点为起点只能找到一条增广路。每找到一条增广路，匹配数便加一。注意实际实现的时候并没有把边标记为匹配边与未匹配边。连接两个匹配点的路径显然是匹配边。 代码1234567891011121314bool dfs(int u) &#123; for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if (!vis[v]) &#123;//vis数组用来标记该点有没有在本次dfs中被遍历过 vis[v] = true;//更改状态，标记为遍历过 if (!pre[v] ||dfs(pre[v])) &#123;//pre数组记录该匹配边中的另一个点， //如果为空的话显然就是一条增广路。如果不为空，则遍历该数组中记录的点，并返回能否找到增广路 pre[v] = u; return true;//已经找到增广路了，结束遍历，返回结果。 &#125; &#125; &#125; return false;//未找到增广路&#125; 相关定义最大匹配数：最大匹配的边数。最小点覆盖数：尽可能少地选择一些点，使得图中任意一条边都至少有一个顶点被选择。最小路径覆盖数：对于一张$ DAG $，选取最少的简单路径数，使得每个顶点只属于一条路径。路径可以仅由一个点组成。换言之，按照这样的路径能遍历到所有的点，且每个点仅被遍历一次。最大独立集：选取最多的点，这些点彼此之间没有连边。最大团：当且仅当该子图是一张完全图（任意两个点之间都有边的图），且该子图不属于该图中的任何完全子图时为该图的最大团。 最小点覆盖数最小点覆盖数 = 最大匹配数（konig定理）。证明过于复杂，因此不在此贴出，请自行百度。 最大独立集最大独立集的点数 = 点数 - 最大匹配数（或者最小点覆盖数）这条定理可以用反证法证明，需要一点前置知识，阅读以下内容之前请务必理解如何证明最小点覆盖数 = 最大匹配这条定理，以及二分图的最小路径覆盖点集如何求出。如果你已经准备好了，那请继续阅读。把二分图的最小点覆盖集删除之后，剩余的点之间如果边，那么最小点覆盖集必然无法覆盖这些边。但是最小点覆盖集必然可以覆盖所有的边，所以上述与最小点覆盖集的性质冲突，故不成立，即最小点覆盖集以外的点之间必然没有边。所以：最大独立集的点数 = 点数 - 最小点覆盖数。又因为最小点覆盖数 = 最大匹配得，所以：最大独立集的点数 = 点数 - 最大匹配数。 最小路径覆盖最小路径覆盖数 = 点数 - 相应二分图的最大匹配数把无向图的每个点拆成两个，分别属于构造出的二分图的两边（对于点$ x $，由 $ x $拆得的左边的点与右边的点分别为 $x_1， x_2 $）。设有边$ (u, v) $，那么在二分图中便有边$ (u_1, v_2) $。因为原图是$ DAG $， 那么每条路径上的点除终点之外，都有且仅有一个后继。假设点都各自是一条路径，那么路径数与点数相同。二分图中每有一条匹配边，便会使一个点有且仅有一个后继。这也意味着这个点不能成为路径的终点。而路径有唯一的终点，所以每有一个匹配，路径便会少一。那么便能得到：最小路径覆盖数 = 点数 - 相应二分图的最大匹配数 最大团最大团点数 = 点数 - 相应的补图的最大匹配数构造出该无向图的补图后，最大团实际上就是补图的最大独立集， 故有：最大团点数 = 点数 - 相应的补图的最大匹配数。]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】树链剖分]]></title>
    <url>%2Farticle%2Ftree-chain-split%2F</url>
    <content type="text"><![CDATA[概述树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护每一条链上的信息。 题目链接概念重结点：子树中结点数目最多的结点；轻节点：父亲节点中除了重结点以外的结点；重边：父亲结点和重结点连成的边；轻边：父亲节点和轻节点连成的边；重链：由多条重边连接而成的路径；轻链：由多条轻边连接而成的路径； 思想把整棵树划分成许多条链，使每个节点都在唯一的链上，对每一条链维护一棵线段树，把在树上的操作转移到线段树上。 树链剖分的策略是轻重边路径剖分，这种策略可以保证整棵树上的轻边和链的数量都不超过 $ O(\log n) $。 流程剖分剖分由两次$ dfs $组成，第一遍求出每个节点的大小、父节点、深度、重结点，即$ size, fa, dep, son $数组。 第二遍$ dfs $求出每个结点所在的链、$ dfn $序，即 $ top, dfn $ 数组。（本模板对链的信息除了链顶结点外并没有需要，因此 $ top $ 数组实际上记录的是该结点所在链的链顶结点的下标，具体用处见下文）。 对于一个结点，如果该结点不是其父节点的重结点或该结点为根节点，则创建一条以该结点为链顶结点的链，否则该节点与其父节点属于同一条链。 线段树使用线段树对这棵树进行维护，以 $ dfn $为新的下标。 查询与修改路径信息修改或查询$ u, v $之间路径上的信息，采取以下策略。首先假设$ u $的深度更大，那么修改或查询$ u $所在链的链顶结点到$ u $这条路径上所有结点的信息，然后将$ u $跳到其链顶结点的父节点。重复以上步骤直到$ u $ 与$ v $在同一条链上为止。最后修改或查询两点间上结点路径的信息。 最近公共祖先不难看出，上述查询或修改路径的过程，实际上是分别修改或查询了$ u $ 到两点间最近公共祖先的路径与$ v $到两点间最近公共祖先的路径，所以不难看出，只需去掉查询与修改路径信息的过程，即可求得最近公共祖先。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;const int MAXN = 1e5 + 7;struct Edge &#123; int t, next;&#125; edge[MAXN &lt;&lt; 1];struct SegmentTree &#123; int l, r, sum, add;&#125; t[MAXN &lt;&lt; 2];int n, m, root, HA, w[MAXN];int cnt, head[MAXN];int size[MAXN], son[MAXN], fa[MAXN], pos[MAXN], dep[MAXN], top[MAXN], dfn[MAXN], ts;inline void Read(int &amp;x) &#123; int flag = 1, ret = 0; char ch = getchar(); while (!isdigit(ch)) &#123; if(ch == '-') flag = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; ret = ret * 10 + ch - '0'; ch = getchar(); &#125; x = flag * ret;&#125;inline void add(int u, int v) &#123; cnt++; edge[cnt].t = v; edge[cnt].next = head[u]; head[u] = cnt;&#125;void dfs1(int u, int father) &#123; fa[u] = father; dep[u] = dep[father] + 1; size[u] = 1; int maxSize = 0; for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if(v == father) continue; dfs1(v, u); size[u] += size[v]; if (maxSize &lt; size[v]) &#123; maxSize = size[v]; son[u] = v; &#125; &#125;&#125;void dfs2(int u, int tops) &#123; dfn[u] = ++ts; top[u] = tops; pos[ts] = u; if(son[u]) dfs2(son[u], tops); for (int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if(v != son[u] &amp;&amp; fa[v] == u) dfs2(v, v); &#125;&#125;void build(int x, int left, int right) &#123; t[x].l = left; t[x].r = right; if (left == right) &#123; t[x].sum = w[pos[left]]; return; &#125; int mid = (left + right) &gt;&gt; 1; build(x &lt;&lt; 1, left, mid); build(x &lt;&lt; 1 | 1, mid + 1, right); t[x].sum = (t[x &lt;&lt; 1].sum + t[x &lt;&lt; 1 | 1].sum) % HA;&#125;inline void cover(int x, int d) &#123; t[x].add = (t[x].add + d) % HA; t[x].sum = (t[x].sum + (t[x].r - t[x].l + 1) * d) % HA;&#125;void pushDown(int x) &#123; if (t[x].add &amp;&amp; t[x].l != t[x].r) &#123; cover(x &lt;&lt; 1, t[x].add); cover(x &lt;&lt; 1 | 1, t[x].add); t[x].add = 0; &#125;&#125;inline void pushUp(int x) &#123; t[x].sum = (t[x &lt;&lt; 1].sum + t[x &lt;&lt; 1 | 1].sum) % HA;&#125;void update(int x, int l, int r, int d) &#123; if (t[x].l == l &amp;&amp; t[x].r == r) &#123; cover(x, d); return; &#125; pushDown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (r &lt;= mid) &#123; update(x &lt;&lt; 1, l, r, d); &#125; else if (l &gt; mid) &#123; update(x &lt;&lt; 1 | 1, l, r, d); &#125; else &#123; update(x &lt;&lt; 1, l, mid, d); update(x &lt;&lt; 1 | 1, mid + 1, r, d); &#125; pushUp(x);&#125;int query(int x, int l, int r) &#123; if (t[x].l == l &amp;&amp; t[x].r == r) &#123; return t[x].sum % HA; &#125; pushDown(x); int mid = (t[x].l + t[x].r) &gt;&gt; 1; if (r &lt;= mid) &#123; return query(x &lt;&lt; 1, l, r); &#125; else if (l &gt; mid) &#123; return query(x &lt;&lt; 1 | 1, l, r); &#125; else &#123; return (query(x &lt;&lt; 1, l, mid) + query(x &lt;&lt; 1 | 1, mid + 1, r)) % HA; &#125;&#125;void solveUpdate(int a, int b, int d) &#123; while (top[a] != top[b]) &#123; if(dep[top[a]] &lt; dep[top[b]]) std::swap(a, b); update(1, dfn[top[a]], dfn[a], d); a = fa[top[a]]; &#125; if (dfn[a] &gt; dfn[b]) std::swap(a, b); update(1, dfn[a], dfn[b], d);&#125;int solveQuery(int a, int b) &#123; int ret = 0; while (top[a] != top[b]) &#123; if(dep[top[a]] &lt; dep[top[b]]) std::swap(a, b); ret = (ret + query(1, dfn[top[a]], dfn[a])) % HA; a = fa[top[a]]; &#125; if (dfn[a] &gt; dfn[b]) std::swap(a, b); ret = (ret + query(1, dfn[a], dfn[b])) % HA; return ret;&#125;void treeUpdate(int u, int d) &#123; update(1, dfn[u], dfn[u] + size[u] - 1, d);&#125;int treeQuery(int u) &#123; return query(1, dfn[u], dfn[u] + size[u] - 1);&#125;int main(int argc, char *argv[]) &#123; Read(n), Read(m), Read(root), Read(HA); for (int i = 1; i &lt;= n; i++) &#123; Read(w[i]); &#125; int u, v; for(int i = 1; i &lt; n; i++) &#123; Read(u), Read(v); add(u, v); add(v, u); &#125; dfs1(root, 0); dfs2(root, root); build(1, 1, n); int c, x, y, z; for (int i = 1; i &lt;= m; i++) &#123; Read(c); if (c == 1) &#123; Read(x), Read(y), Read(z); solveUpdate(x, y, z); &#125; else if (c == 2) &#123; Read(x), Read(y); printf("%d\n", solveQuery(x, y)); &#125; else if (c == 3) &#123; Read(x), Read(y); treeUpdate(x, y); &#125; else if (c == 4) &#123; Read(x); printf("%d\n", treeQuery(x)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2010】超级钢琴]]></title>
    <url>%2Farticle%2F%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%2F</url>
    <content type="text"><![CDATA[题目描述小Z是一个小有名气的钢琴家，最近C博士送给了小Z一架超级钢琴，小Z希望能够用这架钢琴创作出世界上最美妙的音乐。 这架超级钢琴可以弹奏出 $ n $个音符，编号为 $ 1 $ 至 $ n $ 。第 $ i $ 个音符的美妙度为 $ A_i $，其中 $ A_i $可正可负。 一个“超级和弦”由若干个编号连续的音符组成，包含的音符个数不少于 $ L $ 且不多于 $ R $。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。 小Z决定创作一首由k个超级和弦组成的乐曲，为了使得乐曲更加动听，小Z要求该乐曲由k个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。小Z想知道他能够创作出来的乐曲美妙度最大值是多少。 输入输出格式输出格式输入第一行包含四个正整数 $ n,k,L,R $。其中 $ n $ 为音符的个数， $ k $ 为乐曲所包含的超级和弦个数，$ L $和 $ R $分别是超级和弦所包含音符个数的下限和上限。 接下来 $ n $ 行，每行包含一个整数$ A_i $，表示按编号从小到大每个音符的美妙度。 输入格式输出只有一个整数，表示乐曲美妙度的最大值。 输入输出样例输入样例123454 3 2 332-68 输出样例111 说明123451. 音符1 ~ 2，美妙度为3 + 2 = 52. 音符2 ~ 3，美妙度为2 + (-6) = -43. 音符3 ~ 4，美妙度为(-6) + 8 = 24. 音符1 ~ 3，美妙度为3 + 2 + (-6) = -15. 音符2 ~ 4，美妙度为2 + (-6) + 8 = 4 最优方案为：乐曲由和弦1，和弦3，和弦5组成，美妙度为5 + 2 + 4 = 11。 所有数据满足：$ -1000 \leq A_i \leq 1000, 1 \leq L \leq R \leq n $ 且保证一定存在满足要求的乐曲。 题目链接思路暴力解法整理一下这个题的题意，其实就是求序列长度在 $ [l, r] $ 范围内的的前 $ k $ 大序列的和。 最暴力的想法当然是枚举序列的长度，然后枚举端点，再维护一个记录前k大序列值的数组，每次求到一个新的序列和，暴力更新。 既然是最暴力的想法，当然可以优化，而这道题优化之后就能得到正解。 优化优化一既然是求序列长度和，聪明的你有没有想到什么奇技淫巧呢？ 这…这不是前缀和吗？ 我们可以预处理一个前缀和的数组，这样知道长度和端点之后就可以 $ O(1) $ 地求序列和了。 优化二暴力解法中，有提到枚举区间长度和端点对吧？ 我们可以进行另一个优化。 先枚举左端点，这样我们就可以根据左端点的下标和给出的 $ l, r $ 来求出右端点的范围了。 根据前缀和的定义，已知左端点之后，只需要最大化从 $ 1 $ 到右端点的前缀和即可。 然而我们已经知道右端点的范围了，那么这就是一个 $ RMQ $ 问题。可以用代码简单的 $ ST $ 表来解决这个问题，只需进行 $ O(n \log_2(n)) $ 复杂度的预处理，即可进行 $ O(1) $ 时间复杂度的查询。 你非要写线段树也不拦着你。 优化三对于每次通过枚举端点求出的序列，定义一个四元组 $ (s, t, l, r) $ , $ s, t $ 分别表示左右端点的下标， $ l, r $ 表示右端点的范围。 现在的暴力算法，只剩下求前 $ k $ 大的序列这个操作没有优化过了。实际上，动态求前 $ k $ 大，堆这种数据结构是再方便不过了，况且 $ C++ $ 的 $ STL $ 库里还有优先队列这种方便的东西。 利用堆以区间长度为关键字，在堆中维护这些四元组。此时的堆为大根堆。 整理这样的话，先枚举序列的，再利用求在右端点范围内的前缀和最大值，再用堆维护优化三中提到的四元组。 然后，边弹出堆顶，边插入新的四元组 $ (s, summax(l, t - 1), l, t - 1) $ 和 $ (s, summax(t + 1, r), t + 1, r) $。其中 $ max $ 表示区间内前缀和最大的端点的下标。因为如果不插入的话只是以每个点为左端点求最大值，然而这 $ k $ 个序列的左端点可以重复，所以需要把这个右端点扣掉后再压入堆。弹出堆顶 $ k $ 次，和即为答案。这一步 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;climits&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endlconst int MAXN = 500000 + 7;int f[MAXN][22], sum[MAXN];int n, k, L, R;long long ans;struct Node &#123; int s, l, r, t; bool operator &lt; (const Node &amp;x) const &#123; return sum[t] - sum[s - 1] &lt; sum[x.t] - sum[x.s - 1]; &#125;&#125;;std::priority_queue&lt;Node&gt; heap;inline int mx(int x, int y) &#123; return sum[x] &gt; sum[y] ? x : y;&#125;inline int query(int l, int r) &#123; if(l &gt; r) return -1; int k = std::log(r - l + 1) / std::log(2); return mx(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;k, &amp;L, &amp;R); int w; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;w); sum[i] = sum[i - 1] + w; f[i][0] = i; &#125; for (int j = 1; j &lt;= 19; j++) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; f[i][j] = mx(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; for (int i = 1; i + L - 1 &lt;= n; i++) &#123; int right = std::min(n, i + R - 1); heap.push((Node) &#123;i, i + L - 1, right, query(i + L - 1, right)&#125;); &#125; int cnt = 0; while (cnt &lt; k) &#123; cnt++; Node g = heap.top(); heap.pop(); ans += sum[g.t] - sum[g.s - 1]; int q1 = query(g.l, g.t - 1); int q2 = query(g.t + 1, g.r); if(~q1) heap.push((Node) &#123;g.s, g.l, g.t - 1, q1&#125;); if(~q2) heap.push((Node) &#123;g.s, g.t + 1, g.r, q2&#125;); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>堆</tag>
        <tag>前缀和</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】线段树]]></title>
    <url>%2Farticle%2FSegmentTree%2F</url>
    <content type="text"><![CDATA[概述线段树是一种二叉搜索树，用来维护区间内的符合区间加法的值，支持高效的查询与修改操作。每一次操作的时间复杂度是$ O(log_2N) $ 原理线段树把区间[l,r]分成了[l,mid]与[mid+1,r]两部分。线段树把区间[1,n]一直递归地划分下去，直到区间内只有一个点为止，也就是到达了叶子结点。线段树的每个节点都存储了这个序列的一段区间，从根节点开始按照刚才所叙述的划分方法一直划分到叶子结点。每个结点都存储着这个区间的信息，以优化查询的时间。 Lazytag按照这种方式存储序列可以很快地查询这段区间内维护的值，因为是二叉树，所以时间复杂度为$ log_2N $。但是如果进行区间修改的话要修改的值反而更多了，该如何解决呢？那就是Lazytag。 要进行区间修改时，只修改这个区间的节点代表的值，不修改它孩子节点的值，而是用一个标记记录下来，表示这个区间要整体修改一个值。当在有标记的节点进行查询与修改操作时，在把这个标记下推(也就是代码中的push_down函数)。这样就能避免不必要的区间修改。 混合运算当一颗线段树同时要支持区间加法与区间乘法时，需要特别注意运算顺序。也就是在下推标记的时候，先进行乘法标记的下推，再进行加法标记的下推。 代码题目链接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;typedef long long ll;const int MAXN = 100000 + 7;struct SegmentTree;SegmentTree *New(int , int , SegmentTree *, SegmentTree *);int n, m, p;struct SegmentTree &#123; int l, r; ll sum, add, mul; SegmentTree *lc, *rc; static SegmentTree *build(int left, int right) &#123; int mid = (left + right) &gt;&gt; 1; return left == right ? New(left, right, NULL, NULL) : New(left, right, build(left, mid), build(mid + 1, right)); &#125; void push_up() &#123; sum = (lc-&gt;sum + rc-&gt;sum) % p; &#125; void mulCover(ll d) &#123; sum = (sum * d) % p; mul = (mul * d) % p; add = (add * d) % p; &#125; void addCover(ll d) &#123; add = (add + d) % p; sum = (sum + d * (r - l + 1)) % p; &#125; void push_down() &#123; lc-&gt;mulCover(mul); lc-&gt;addCover(add); rc-&gt;mulCover(mul); rc-&gt;addCover(add); mul = 1; add = 0; &#125; void mulUpdate(int left, int right, ll d) &#123; if(left &gt; r || right &lt; l) return; else if(left &lt;= l &amp;&amp; right &gt;= r) mulCover(d); else &#123; push_down(); lc-&gt;mulUpdate(left, right, d); rc-&gt;mulUpdate(left, right, d); push_up(); &#125; &#125; void addUpdate(int left, int right, ll d) &#123; if(left &gt; r || right &lt; l) return; else if(left &lt;= l &amp;&amp; right &gt;= r) addCover(d); else &#123; push_down(); lc-&gt;addUpdate(left, right, d); rc-&gt;addUpdate(left, right, d); push_up(); &#125; &#125; ll query(int left, int right) &#123; if(left &gt; r || right &lt; l) return 0; else if(left &lt;= l &amp;&amp; right &gt;= r) return sum; else &#123; push_down(); return (lc-&gt;query(left, right) + rc-&gt;query(left, right)) % p; &#125; &#125;&#125; *tree, poor[MAXN * 4], *tail = poor;SegmentTree *New(int l, int r, SegmentTree *lc, SegmentTree *rc) &#123; SegmentTree *ret = ++tail; ret-&gt;sum = ret-&gt;add = 0; ret-&gt;mul = 1; ret-&gt;l = l; ret-&gt;r = r; ret-&gt;lc = lc; ret-&gt;rc = rc; return ret;&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;p); tree = SegmentTree::build(1, n); int now; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;now); tree-&gt;addUpdate(i, i, now); &#125; int flag, x, y, k; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d %d %d", &amp;flag, &amp;x, &amp;y); if(flag == 1) &#123; scanf("%d", &amp;k); tree-&gt;mulUpdate(x, y, k); &#125; else if(flag == 2) &#123; scanf("%d", &amp;k); tree-&gt;addUpdate(x, y, k); &#125; else if(flag == 3) &#123; printf("%lld\n", tree-&gt;query(x, y)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】缩点]]></title>
    <url>%2Farticle%2F%E7%BC%A9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个n个点m条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。 允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。 输入输出格式输入格式第一行，n,m 第二行，n个整数，依次代表点权 第三至m+2行，每行两个整数u,v，表示u-&gt;v有一条有向边 输出格式共一行，最大的点权之和。 输入输出样例输入样例12342 21 11 22 1 输出样例12 说明n&lt;=10^4,m&lt;=10^5,点权&lt;=1000 算法：Tarjan缩点+DAGdp 题目链接代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;climits&gt;const int MAXN = 10000 + 7;const int MAXM = 100000 + 7;struct Edge &#123; int s, t; int next;&#125; edge[MAXM], es[MAXM];int head[MAXN], cnt, h[MAXN], c;std::stack&lt;int&gt; stack;bool inStack[MAXN];int dfn[MAXN], low[MAXN], sccTime, scc[MAXN], in[MAXN]; int n, m, p[MAXN], f[MAXN];inline void Read(int &amp;x) &#123; int flag = 1, ret = 0; x = 0; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') &#123; if(ch == '-') flag = -1; ch = getchar(); &#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') &#123; ret = (ret &lt;&lt; 3) + (ret &lt;&lt; 1) + ch - '0'; ch = getchar(); &#125; x = ret; return;&#125;inline void add(const int &amp;s, const int &amp;t) &#123; cnt++; edge[cnt].s = s; edge[cnt].t = t; edge[cnt].next = head[s]; head[s] = cnt;&#125;inline void addScc(const int &amp;s, const int &amp;t) &#123; ++c; es[c].s = s; es[c].t = t; es[c].next = h[s]; h[s] = c;&#125;void Tarjan(const int &amp;u) &#123; dfn[u] = low[u] = ++sccTime; stack.push(u); inStack[u] = true; for(int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if(!dfn[v]) &#123; Tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if(inStack[v]) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; while(1) &#123; int x = stack.top(); stack.pop(); inStack[x] = false; scc[x] = u; if(x == u) break; p[u] += p[x]; &#125; &#125;&#125;inline int dp() &#123; std::queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++) &#123; if(scc[i] == i &amp;&amp; !in[i]) &#123; q.push(i); f[i] = p[i]; &#125; &#125; while(!q.empty()) &#123; int u = q.front();q.pop(); for(int e = h[u]; e; e = es[e].next) &#123; int v = es[e].t; f[v] = std::max(f[v], f[u] + p[v]); in[v]--; if(!in[v]) q.push(v); &#125; &#125; int ans = INT_MIN; for(int i = 1; i &lt;= n; i++) &#123; ans = std::max(ans, f[i]); &#125; return ans;&#125;int main(int argc, char *argv[]) &#123; Read(n);Read(m); for(int i = 1; i &lt;= n; i++) Read(p[i]); int u, v; for(int i = 1; i &lt;= m; i++) &#123; Read(u);Read(v); add(u, v); &#125; for(int i = 1; i &lt;= n; i++ )&#123; if(!dfn[i]) Tarjan(i); &#125; for(int i = 1; i &lt;= m; i++) &#123; int s = scc[edge[i].s], t = scc[edge[i].t]; if(s != t) &#123; addScc(s, t); in[t]++; &#125; &#125; printf("%d\n", dp()); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>强连通分量</tag>
        <tag>Tarjan</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【USACO5.3】校园网Network of Schools]]></title>
    <url>%2Farticle%2F%E3%80%90USACO5.3%E3%80%91%E6%A0%A1%E5%9B%AD%E7%BD%91Network%20of%20Schools%2F</url>
    <content type="text"><![CDATA[题目描述一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 输入输出格式输入格式输入文件的第一行包括一个整数 N：网络中的学校数目（2 &lt;= N &lt;= 100）。学校用前 N 个正整数标识。 接下来 N 行中每行都表示一个接收学校列表（分发列表）。第 i+1 行包括学校 i 的接收学校的标识符。每个列表用 0 结束。空列表只用一个 0 表示。 输出文件你的程序应该在输出文件中输出两行。 第一行应该包括一个正整数：子任务 A 的解。 第二行应该包括子任务 B 的解。 输入输出样例输入样例12345652 4 3 04 5 0001 0 输出样例1212 题目链接思路读完题目之后显然能看出来需要缩点。通过Tarjan算法缩完点之后能得到一张有向无环图。那么问题的答案显然就是求从至少几个点出发能到达所有的点和至少加入几条边来使整个图构成一个强连通分量。第一个问题的答案显然是入度为0的强连通分量的数量。因为只有从这个入度为0的点开始遍历才能遍历到这个点，而入度不为0的点显然是可以以其他点为起点遍历到。所以答案是正确的。对于第二个问题，需要从强连通分量的定义来入手。强连通分量的任意两个点都能相互到达，这也就意味着所有点的出度和入度最起码为1。所以只需要对入度为0的点的数量和出度为0的点的数量取 $ max $就是答案了。值得一提的是需要特判只有一个点的情况。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;stack&gt;const int MAXN = 100 + 7;struct Edge &#123; int s, t; int next;&#125; edge[MAXN * (MAXN - 1)];int head[MAXN], cnt;std::stack&lt;int&gt; stack;int dfn[MAXN], low[MAXN], chu[MAXN], ru[MAXN], sccTime, sccSize, scc[MAXN];bool inStack[MAXN];inline void add(const int &amp;s, const int &amp;t) &#123; edge[++cnt].s = s; edge[cnt].t = t; edge[cnt].next = head[s]; head[s] = cnt;&#125;void dfs(const int &amp;u) &#123; dfn[u] = low[u] = ++sccTime; stack.push(u); inStack[u] = true; for(int e = head[u]; e; e = edge[e].next) &#123; int v = edge[e].t; if(!dfn[v]) &#123; dfs(v); low[u] = std::min(low[u], low[v]); &#125; else if(inStack[v]) &#123; low[u] = std::min(low[u], dfn[v]); &#125; &#125; if(dfn[u] == low[u]) &#123; sccSize++; while(1) &#123; int x = stack.top(); stack.pop(); inStack[x] = false; scc[x] = sccSize; if(u == x) break; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; int n; scanf("%d", &amp;n); int t; for(int i = 1; i &lt;= n; i++) &#123; while(1) &#123; scanf("%d", &amp;t); if(!t) break; add(i, t); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(!dfn[i]) dfs(i); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int e = head[i]; e; e = edge[e].next) &#123; int t = edge[e].t; if(scc[i] != scc[t]) &#123; chu[scc[i]]++; ru[scc[t]]++; &#125; &#125; &#125; int cntChu = 0, cntRu = 0; for(int i = 1; i &lt;= sccSize; i++) &#123; if(chu[i] == 0) cntChu++; if(ru[i] == 0) cntRu++; &#125; if(sccSize == 1) &#123; printf("%d\n%d\n", 1, 0); return 0; &#125; printf("%d\n", cntRu); printf("%d\n", std::max(cntChu, cntRu)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HNOI2009】最小环]]></title>
    <url>%2Farticle%2F%E6%9C%80%E5%B0%8F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[题目链接【HNOI2009】最小环 思路题目要求输出边权平均值最小的环的平均值，再看一眼数据范围，不难联想到我们可以二分答案。剩下的就是如何去check我们的答案。我们让所有边减去一个我们二分平均值，如果存在负环，说明这个答案是成立的。什么算法能用来求负环呢？显而易见是SPFA！值得一提的的地方是常规的队列实现的SPFA用来求负环效率十分低下，因此需要用DFS版的SPFA来求负环。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 3005;const int MAXE = 10005; struct Edge &#123; int v; double w; int next;&#125; e[MAXE];int head[MAXN], cnt = 0, n, m;double eps = 1e-9, dis[MAXN];bool vis[MAXN], flag;inline void add(int u, int v, double w) &#123; cnt++; e[cnt].v = v; e[cnt].w = w; e[cnt].next = head[u]; head[u] = cnt;&#125;void spfa(int x, double mid) &#123; vis[x] = true; for(int i = head[x]; i != 0; i = e[i].next) &#123; int v = e[i].v; if(dis[v] &gt; dis[x] + e[i].w - mid) &#123; if(vis[v]) &#123; flag = true; return; &#125; dis[v] = dis[x] + e[i].w - mid; spfa(v, mid); &#125; &#125; vis[x] = false;&#125;inline bool check(double mid) &#123; memset(vis, 0, sizeof(vis)); memset(dis, 0, sizeof(dis)); for(int i = 1; i &lt;= n; i++) &#123; flag = 0; spfa(i,mid); if(flag) return true; &#125; return false;&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d", &amp;n, &amp;m); int u, v; for(int i = 1, u, v; i &lt;= m; i++) &#123; double w; scanf("%d %d %lf", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; double l = -1e5, r = 1e5, mid; while(r-l &gt; eps) &#123; mid = (l + r)/2; if(check(mid)) r = mid; else l = mid; &#125; printf("%.8f\n", mid); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分答案</tag>
        <tag>分数规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【SCOI2005】互不侵犯King]]></title>
    <url>%2Farticle%2F%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing%2F</url>
    <content type="text"><![CDATA[题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 输入输出格式输入格式只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出格式所得的方案数 输入输出样例输入样例13 2 输出样例116 思路这道题看完题目描述显然就是一道搜索或者是动态规划，观察数据范围暴搜显然是会超时的。所以我们直接想想动态规划的思路。很多人看到这道题的时候会下意识地想到八皇后问题，实际上这两道题确实有共同之处。我们可以像八皇后那道题一样逐行处理。经过思考我们可以很容易地出状态转移方程。只需把能转移到当前状态的状态累加即可。需要注意的是第三维下标应用了状态也压缩的技巧来存储当前这行国王是如何摆放的。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;climits&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; std::endlint n, k;long long f[10][100][1024];int pop_count(int s) &#123; int ans = 0; while(s) &#123; if(s &amp; 1) ans++; s &gt;&gt;= 1; &#125; return ans;&#125;bool is_valid(int s) &#123; bool ans = bool(s &amp; (s &gt;&gt; 1)); return !ans;&#125;bool is_valid2(int s, int ss) &#123; bool ans = bool (s &amp; ss) || (s &amp; (ss &gt;&gt; 1)) || (s &amp; (ss &lt;&lt; 1)); return !ans;&#125;int main(int argc, char *argv[]) &#123; scanf("%d %d", &amp;n, &amp;k); long long l = 1 &lt;&lt; n; f[0][0][0] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= k; j++) for(int t1 = 0; t1 &lt; l; t1++) if(is_valid(t1) &amp;&amp; pop_count(t1) &lt;= j) for(int t2 = 0; t2 &lt; l; t2++) if(is_valid(t2) &amp;&amp; is_valid2(t1, t2))&#123; f[i][j][t1] += f[i-1][j-pop_count(t1)][t2]; /*DEBUG(f[i][j][t1])*/; &#125; long long ans = 0; for(int t = 0; t &lt; l; t++) if(is_valid(t)) ans += f[n][k][t] /*DEBUG(ans)*/; printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】01背包]]></title>
    <url>%2Farticle%2F01bags%2F</url>
    <content type="text"><![CDATA[f[i]表示背包已用i容量时能得到的最大价值，value[i]表示第i个物体的价值，size[i]表示第i个物品所要占据的背包容量（或者说是重量、时间之类的）。那么我们的决策就是要不要把当前处理的物品放入背包中。我们可以得到方程$ f[i]=\max(f[i],f[i-size[i]]+value[i])$。题目链接采药 代码实现1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;iostream&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; std::endlusing namespace std;const int MAXN = 1000 + 5; int n, m;int value[MAXN], size[MAXN], f[MAXN];int main(int argc, char *argv[]) &#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d %d", &amp;size[i], &amp;value[i]); &#125; for(int i = 1; i &lt;= m; i++) for(int j = n; j &gt;= size[i]; j--) &#123; f[j] = max(f[j], f[j - size[i]] + value[i]); &#125; printf("%d\n", f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijsktra算法]]></title>
    <url>%2Farticle%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[Dijkstra算法是一种用于求最短路径的算法，用于求一个节点到其他所有节点的最短路径。与其他的最短路径算法一样，都采用松弛操作，并且运用了贪心的思想。适用于处理不存在负边权的稀疏图，算法的时间复杂度为 $ O(N^2) $,采用堆优化后可以达到$ O(N\log N) $。下面给出堆优化写法，题目参考Heat Wave。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; std::endl const int MAXN = 6200 + 5;using namespace std;struct Node;struct Edge;struct Node &#123; int dist; bool used; Edge *firstEdge;&#125; node[MAXN];struct Edge &#123; Node *s, *t; int w; Edge *next; Edge(Node *s, Node *t, int w) : s(s), t(t), w(w), next(s-&gt;firstEdge)&#123;&#125;&#125;;void add(const int &amp;s, const int &amp;t, const int &amp;w) &#123; node[s].firstEdge = new Edge(&amp;node[s], &amp;node[t], w); node[t].firstEdge = new Edge(&amp;node[t], &amp;node[s], w);&#125;int dijkstra(const int &amp;n, const int &amp;s, const int &amp;t) &#123; for(int i = 1; i &lt;= n; i++) &#123; node[i].dist = INT_MAX; node[i].used = false; &#125; priority_queue&lt;pair&lt;int, Node*&gt;, vector&lt;pair&lt;int, Node*&gt; &gt;, greater&lt;pair&lt;int, Node*&gt; &gt; &gt; heap; heap.push(make_pair(node[s].dist = 0, &amp;node[s])); while(!heap.empty()) &#123; Node *u = heap.top().second; heap.pop(); if(u-&gt;used) continue; u-&gt;used = true; for(Edge *e = u-&gt;firstEdge; e; e = e-&gt;next) &#123; if(e-&gt;t-&gt;dist &gt; e-&gt;w + u-&gt;dist) &#123; e-&gt;t-&gt;dist = e-&gt;w + u-&gt;dist; heap.push(make_pair(e-&gt;t-&gt;dist, e-&gt;t)); &#125; &#125; &#125; return node[t].dist;&#125;int main(int argc, char *argv[]) &#123; int n, m, s, t; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;s, &amp;t); for(int i = 1; i &lt;= m; i++) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125; printf("%d\n", dijkstra(n, s, t)); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模板】SPFA算法]]></title>
    <url>%2Farticle%2FSPFA%2F</url>
    <content type="text"><![CDATA[SPFA算法是Bellman-Ford（蛤？你说你不知道Bellman-Ford算法？）算法的队列实现方法，采取动态逼近的方式来求得单源最短路，时间复杂度为O（ek）e为边数，k是所有点进队的平均次数。适用于不存在负权回路的稀疏图。下面给出指针写法，题目参考洛谷【模板】单源最短路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;climits&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; std::endl;#define MAXN 10001using namespace std;int n,m,s;struct Node;struct Edge;//定义结构体，Node为节点，Edge为边struct Node&#123; Edge *firstEdge; int dist;//距起点的最小距离 bool inQueue;//判断是否再队列中&#125;node[MAXN];struct Edge&#123; Node *from,*to;//起点与终点 int w;//边权 Edge *next; Edge(Node *from,Node *to,int w) : from(from),to(to),w(w),next(from -&gt; firstEdge) &#123;&#125;&#125;;void add(int s,int t,int w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w);//把边加入结构体&#125;void spfa()&#123; for(int i = 1;i &lt;= n;i++)&#123; node[i].dist = INT_MAX; node[i].inQueue = false; &#125;//初始化，使所有点到起点的距离为无穷大，所有点都不在队列中 queue &lt;Node *&gt; q;//通过队列来进行松弛操作，动态逼近，这里采用STL写法 q.push(&amp;node[s]); node[s].inQueue = true; node[s].dist = 0;//把起点入队 while(!q.empty())&#123;//队列不能为空 Node *u = q.front();//每次从队首处理 q.pop(); u -&gt; inQueue = false; for(Edge *e = u -&gt; firstEdge;e;e = e -&gt; next)&#123;//枚举所有与u相连的边，查找能够更新dist的点 Node *v = e -&gt; to; if(v -&gt; dist &gt; e -&gt; w + u -&gt; dist)&#123; v -&gt; dist = e -&gt; w + u -&gt; dist; if(! v-&gt; inQueue)&#123; q.push(v); v -&gt; inQueue = true;//如果不在队列中，就使其入队 &#125; &#125; &#125; &#125; &#125;int main(int argc,char *argv[])&#123; scanf("%d %d %d",&amp;n,&amp;m,&amp;s); int u,v,l; for(int i = 1;i &lt;= m;i++)&#123; //读入 scanf("%d %d %d",&amp;u,&amp;v,&amp;l); add(u,v,l); &#125; spfa(); for(int i = 1;i &lt;= n;i++) printf("%d ",node[i].dist); return 0;&#125;]]></content>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B Problem]]></title>
    <url>%2Farticle%2FL1001%2F</url>
    <content type="text"><![CDATA[By吴雨航1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;struct SegmentTree &#123; int left,right,sum,tag; SegmentTree *lc,*rc; SegmentTree(int left,int right,SegmentTree *lc,SegmentTree *rc) : left(left), right(right), lc(lc), rc(rc), sum(0), tag(0) &#123;&#125; static SegmentTree *build(int l,int r)&#123; int mid = (l + r) &gt;&gt; 1; return l == r ? new SegmentTree(l,r,NULL,NULL) : new SegmentTree(l,r,build(l,mid),build(mid+1,r)); &#125; void cover(int delta)&#123; sum += (right - left + 1) * delta; tag += delta; &#125; void pushDown()&#123; if(tag)&#123; lc-&gt;cover(tag); rc-&gt;cover(tag); tag = 0; &#125; &#125; void modify(int l,int r,int delta)&#123; if(l &gt; right || r &lt; left) return; if(l &lt;= left &amp;&amp; r &gt;= right) cover(delta); else&#123; pushDown(); lc-&gt;modify(l,r,delta); rc-&gt;modify(l,r,delta); sum = lc-&gt;sum + rc-&gt;sum; &#125; &#125; int query(int l,int r)&#123; if(l &gt; right || r &lt; left) return 0; if(l &lt;= left &amp;&amp; r &gt;= right) return sum; else&#123; pushDown(); return lc-&gt;query(l,r) + rc-&gt;query(l,r); &#125; &#125;&#125;;int main()&#123; std::ios::sync_with_stdio(false); int a; SegmentTree *segt; segt = SegmentTree::build(1,2); for(int i = 1;i &lt;= 2;i++)&#123; std::cin &gt;&gt; a; segt-&gt;modify(i,i,a); &#125; std::cout &lt;&lt; segt-&gt;query(1,2) &lt;&lt; std::endl; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
